I did not handle any errors in this challenge as they would come from user input and the challenge specfically stated to assume that input is well-formed. For simplicity I've used some of Javascript's default string<->number handling. I've also assumed that the timer never schedules something for "now", only something at least one second in the future. We are also going to assume that no time passes during an iteration of 'cron' - a single iteration of 'cron' runs in less than a fifth of a second so it is unlikely that the second will change although it may happen at times.

The first part of the challenge was to simply read in the input. The function 'calculateCronsFromFile' is called on the user-given textfile name. This function uses Node's own methods to read a file line-by-line. For each line, the string is converted into an array of parameters and the first three parameters (seconds, minutes, hours) are passed to the 'cron' function, whose output is displayed by 'console.log'. The time complexity of this method is linear, O(n) where n is the number of lines in the given file. Its space complexity is constant (O(1)): although we are looping through a file we are reading only one line at a time, breaking it into an array of length 4, and performing the function on it.

Next the time (seconds, minutes, hours) of the next scheduled task are calculated. To do this I created a method to calculate each part: 'calculateSeconds', 'calculateMinutes', and 'calculateHours'. These could have been combined into one method, and in fact was what I originally did (named 'calculateUnits'), but as each was slightly different I preferred having each one in their own method. This obviously meant more written code but it made each method's algorithm much clearer - it was easy to get lost in the logic when the units were generic and logic errors were much harder to find. 

For all units, if there is no wildcard the unit stays as-is. If there is a wildcard the unit is calculated slightly differently depending on what it is. For seconds, if the hour is not a wildcard or the minute is not a wildcard AND is not equal to the current minute, the seconds are set to 0. Otherwise the seconds are the current seconds incremented by 1. Similarly, if minutes is a wildcard and hours is NOT a wildcard and is also not the current hour we set the minutes to 0. If seconds (which has already been calculated) is later than the current seconds we leave the minute as the current minute. Otherwise we increment by 1. Lastly, if hours is a wildcard and either minute or minute + seconds is in the future we use the current hour, otherwise we increment by 1. Each of these functions are run in constant time (O(1)). They also use (O(1)) space.

Once the hours, minutes, and seconds are calculated they are used to create a new date object. This date and the "now" date are input into the method 'differenceInSeconds'. As the name implies, the difference between the two dates are calculated. If the next scheduled task has already passed today then the date is incremented by one day (a simple helper method was made for this). Now that we are guaranteed the next scheduled date is later than the current date we calculate their difference in seconds and return it. This function also runs in constant time and space (O(n)). 

So then, the overall time complexity of this script is linear time (O(n)): we run through a loop of input (the lines from the file) and do constant-time tasks on each iteration. Its space complexity is remains constant (O(1)).