I did not handle any errors in this challenge as they would come from user input and the challenge specfically stated to assume that input is well-formed. I wrote a very simple method which takes two numbers, assumed to be sequential parts of the Fibonacci series, and a length. It then prints the next n-many Fibonacci numbers, where n is equal to the given length. If length is greater than 0, my function takes the two given numbers and adds them together. It then calls itself (with updated parameters to include the calculated sum) to get the next number and subtracts one from length. 

Although this function calls itself recursively, it is not a true "divide and conquer" approach and does not require recursion. I only did this recursively because, for such a small problem,I liked the style and readability better. The solution is really a simple iterative solution where we iterate through length-many times and compute a sum in each iteration. We can expect the function to be called length-many times so its time complexity is linear (O(n)). Its space complexity is constant (O(1)).

Outside of the function we are simply reading the input and mapping each item to a number. This is constant (O(1)) and therefore doesn't affect our time complexity.